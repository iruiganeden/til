GitHub Action

git hub : rx78gp02A@

ワークフローの単位でタスクを自動化する。

GitHub Actions の設定ファイル（workflow ファイル）は、以下の場所に配置する必要があります
<リポジトリのルートディレクトリ>/.github/workflows/

cd <your-cloned-repo>
mkdir -p .github/workflows
touch .github/workflows/ci.yml

ワークフローは、1ファイルにつき、１つ。

ワークフロー名が「.github/workflows/hello.yml」と表示された原因は、
YAMLの文法ミスにより name: Hello が正しく解釈されなかったためです。

GitHub Actions では、name キーが無効（もしくはファイル全体がパースエラー）だった場合、
GitHub は ファイルパスである .github/workflows/hello.yml を代わりに表示します。

・ワークフローの起動方法
GitHubの様々なイベントをトリガーにできる。
手動実行と定期実行も実装可能。

手動実行
onキーでworkflow_dispatchイベントを指定することで手動実行が可能。

定期実行
onキーでscheduleイベントを指定することで定期実行が可能。
cron形式で記述する。
タイムゾーンはUTCとなる。JSTに計算する必要がある。（9時間ずれ）

注意事項
時間ぴったりに起動するとは限らない。
時間にシビアな処理は不向きとなる。

課金モデル
パブリックリポジトリは、無料。
プライベートリポジトリは、有料。
使用時間とストレージ使用量に応じた従量課金となる。
「使用時間」＝「実行時間」＊「ランナーごとに異なる乗率（OS）」

・ワークフローの書き方
コンテキストを直接、シェルコマンドへ埋め込んだ実装は、アンチパターンです。
コンテキストによっては特殊文字が含まれ、シェルコマンドの実行に意図しない影響を与える恐れがあるため。

環境変数経由でコンテキストを渡してクォートする
これを中間環境変数という。

１．コンテキストはシェルコマンドへハードコードせず、環境変数を経由して渡す。
２．環境変数は全てダブルクォーテーションで囲む。


・Variables
環境変数は単一のワークフローのみ有効となる。
複数のワークフローで同じ値を使用したい場合に適用する。

利用するには事前に登録が必要。
リポジトリページから遷移して、登録が必要。

例）
name: Variables
on: push
jobs:
  print:
    runs-on: ubuntu-latest
	env:
	  USERNAME: ${{ vars.USERNAME }} #Variablesの参照
	steps:
	  - run: echo "${USERNAME}"

・Secrets
機密情報を扱う際に使用する
特徴としては、
１．登録した値は暗号化され、GitHub内で安全に管理される。
２．ログ出力時に自動でマスクされる。
３．登録後に値がまったく確認できなくなる。

利用するには事前に登録が必要。
リポジトリページから遷移して、登録が必要。
パスワードなどはVariablesではなく、Secretsを使う。
ログマスクの有無が重要。

例）
name: Secrets
on: push
jobs:
  print:
    runs-on: push
	  runs-on: ubuntu-latest
	  env:
	    PASSWORD: ${{ secrets.PASSWORD }} #Secretsの参照
	  steps:
	    - run: echo "${PASSWORD}" #ログ出力はマスクされる
	    - run: echo "${PASSWORD:0:1}" ${PASSWORD#?} #ログ出力はマスクされない。

・式
${{ <expression> }}の記法となる。
利用できるリテラル
null:null
boolean:true false
number:JSONがサポートする数値（整数・浮動小数点）
string:任意の文字列

・演算子
github Actionでは、演算子の使用に注意すること。
異なる型で比較すると、勝手に値が変換される。
例えば、trueは数値の「1」と解釈される。

・関数
式では関数が利用できる。
文字列比較：contains(),startsWith(),endsWits()
文字列生成：format(),join()
JSON操作：toJSON(),fromJSON()
ハッシュ生成：hashFiles()


・ネーミング
ステップ名とジョブ名
ワークフロー名と同様に、nameキーで指定する。

ワークフロー実行名
run-nameキーを使用すればワークフロー実行名を指定できる。

・ステップ間のデータ共有
ステップ間で値を受け渡しをする場合、少し工夫が必要になる。
1つ目のステップで環境変数を定義しても、2つ目のステップでは未定義状態に戻ってしまう。

ステップ間の値の受け渡し方法は、2つある。
１．GITHUB_OUTPUT環境変数
GitHubActionが管理する特殊なファイルパスが格納されている。
受け渡し側ステップはGITHUB_OUTPUT環境変数へ、キューバリュー形式の文字列を書き出します。
idキーでステップIDを定義する。
例）
 - id: <step-id>
   run: echo "<key>=<value>" >> "${GITHUB_OUTPUT}"
↓
${{ steps.<step-id>.outputs.<key>}}

記述量が多いが、ステップ間の依存関係は明確になるメリットはある。

２．GITHUB_ENV環境変数
特殊なファイルパスが格納されている。
GITHUB_ENV環境変数へキーバリュー形式で次のように値を書き出す。
後続のステップから、通常通り環境変数が参照できる。

受け渡し側ステップでは、ステップIDの死愛知は不要です。
どのステップで環境変数を設定したかを機にする必要はない。
事実上のグローバル変数となる。
そのため、同じ値を参照する場合は効果的だが、ステップ間の依存関係は分かりづらい。
ワークフローが大きくなるとバグの温床になる可能性があるため、不用意な利用は控えるべき。

GITHUB API
パーミッション設計が大切。

継続的インテグレーション（CI）

「コードの変更を頻繁にコードベースへ統合し、正しく動作するか繰り返し検証する」

githubの場合、コードを変更してコードベースへ統合するのはプルリクエストのタイミングとなる。
プルリクエスト時にCIを実行するのが、ベストプラクティスとなる。

開発プロセスの典型例
１．コードを変更して、プルリクエストを作成する
２．プルリクエストをトリガーに、CIを実行して成功するかを確認する
３．CIの実行と同時（もしくはCI実行後）に、コードレビューを実施する
４．CIが全て成功し、コードレビューに合格したらマージする

CIによる検証
・ユニットテストやインテグレーションテストなどの自動テスト
・性的解析ツールによるコードの品質チェック
・リポジトリに混入したクレデンシャルの検出
・コンテナイメージに含まれる依存関係の脆弱性検査
・Infrastructure as Codeの設定ミスやポリシー違反の発見

「リポジトリに混入したクレデンシャルの検出」は、
誤ってコードに含めてしまった秘密情報（APIキー・パスワード・アクセストークン・証明書鍵など）をCIで自動スキャンして見つけ、
ビルドを止めて通知する仕組み


